---
# Deploy to staging environment and do smoke tests

name: CD

concurrency: staging

on:  # Trigger automatically on integration.yml success (merged pull request or direct push)
  workflow_dispatch:
  workflow_run:
    workflows: [CI]
    types: [completed]
    branches: [main]

env:
  AWS_REGION: us-east-2
  ECS_SERVICE: my-service
  ECS_CLUSTER: initial-cluster
  ECS_TASK_DEFINITION: .aws/ecs-task-definition.json
  CONTAINER_NAME: some-nginx
  IMAGE_TAG: ${{ github.event.workflow_run.head_sha }}

jobs:
  # Only trigger if the previous workflow run was successful and the event was not a pull request
  change-staging-manifest:
    if: >-
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event != 'pull_request'
    runs-on: ubuntu-latest
    permissions:
      contents: write    # This is required for actions/checkout
      id-token: write   # This is required for requesting the JWT
    environment: 
      name: Staging
      # You can add here public IPv4 of your task
      url: https://opengitops.dev/

    steps:
      - name: Print the used tag
        run: echo "To staging environmnet will deploy container with image tag  sha-${{ env.IMAGE_TAG }}"

      - name: Print the used tag
        run: echo "Changing the image's tag in the manifest to sha-${{ env.IMAGE_TAG }}"

      - name: Checkout
        uses: actions/checkout@v3

      # TODO change later the manifest file to helm chart and use "helm upgrade" instead of "sed"
      - name: Replace image tag  # Git commands require granting the permissions for read and write for the workflow
        run: |
          echo "Menifest before change:" && cat manifests/deployment.yaml
          sed -i 's/sha-.*/sha-${{ env.IMAGE_TAG }}/' manifests/deployment.yaml
          echo "Menifest after change:" && cat manifests/deployment.yaml
          git config user.name github-actions
          git config user.email github-actions@github.com
          git add manifests/deployment.yaml
          git commit -m "Update the image's tag in the manifest [skip actions]"
          git push

#       - name: Configure AWS credentials
#         uses: aws-actions/configure-aws-credentials@v2
#         with:
#           role-to-assume: arn:aws:iam::152691795422:role/gh-action-role
#           role-session-name: samplerolesession
#           aws-region: ${{ env.AWS_REGION }}

#  Optionally you can use ECR instead of Docker Hub (then you will have to change a lot in CI and CD workflow)
#       - name: Login to Amazon ECR
#         id: login-ecr
#         uses: aws-actions/amazon-ecr-login@aaf69d68aa3fb14c1d5a6be9ac61fe15b48453a2

#       - name: Build, tag, and push image to Amazon ECR
#         id: build-image
#         env:
#           ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
#           IMAGE_TAG: ${{ github.sha }}
#         run: |
#           # Build a docker container and
#           # push it to ECR so that it can
#           # be deployed to ECS.
#           docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
#           docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
#           echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

#       - name: Fill in the new image ID in the Amazon ECS task definition
#         id: task-def
#         uses: aws-actions/amazon-ecs-render-task-definition@97587c9d45a4930bf0e3da8dd2feb2a463cf4a3a
#         with:
#           task-definition: ${{ env.ECS_TASK_DEFINITION }}
#           container-name: ${{ env.CONTAINER_NAME }}
#           image: docker.io/jakubszuber/testing_image:sha-${{ env.IMAGE_TAG }}  # Use just created image by the CI workflow

#       - name: Deploy Amazon ECS task definition
#         uses: aws-actions/amazon-ecs-deploy-task-definition@v1.4.11
#         with:
#           task-definition: ${{ steps.task-def.outputs.task-definition }}
#           service: ${{ env.ECS_SERVICE }}
#           cluster: ${{ env.ECS_CLUSTER }}
#           wait-for-service-stability: true

  # TODO add some smoke test maybe by codeguru or just simply use some command that will check the status of the task or do "curl" on container
  change-production-manifests:
    runs-on: ubuntu-latest
    permissions:
      contents: write
    needs: [change-staging-manifest]
    environment: 
      name: Production
      url: https://pl.wikipedia.org/wiki  # You can add here public IPv4 of your app (production link)

    steps:
      - name: Print the used tag
        run: echo "Changing the image's tag in the manifest to sha-${{ env.IMAGE_TAG }}"
      - name: Checkout
        uses: actions/checkout@v3
      # TODO change later the manifest file to helm chart and use "helm upgrade" instead of "sed"
      - name: Replace image tag  # Git commands require granting the permissions for read and write for the workflow
        run: |
          git config user.name github-actions
          git config user.email github-actions@github.com
          git pull
          echo "Menifest before change:" && cat manifests/deployment.yaml
          sed -i 's/sha-.*/sha-${{ env.IMAGE_TAG }}/' manifests/deployment.yaml
          echo "Menifest after change:" && cat manifests/deployment.yaml
          git add manifests/deployment.yaml
          git commit -m "Update the image's tag in the manifest [skip actions]"
          git push

  notify-slack:
    # Setup guide https://github.com/marketplace/actions/slack-send#technique-3-slack-incoming-webhook
    name: Notify Slack
    needs: [change-production-manifests]
    if: always()
    runs-on: ubuntu-latest
    env: 
      STAT: ${{ needs.change-production-manifests.result }}
    steps:
      - name: TEST1
        run: |
          if [[ "$STAT" == "skipped" ]]; then
            echo "STAT=failure" >> "$GITHUB_ENV"
          fi
      - name: TEST
        run: |
          echo "$STAT"
          echo ${{ env.STAT }}
      - uses: 8398a7/action-slack@v3
        with:
          status: ${{ env.STAT }}
          fields: repo,message,author,commit,action,eventName,ref,workflow,job,took,pullRequest
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL2 }}
        if: always() # Pick up events even if the job fails or is canceled.
