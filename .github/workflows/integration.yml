---
# Complete workflow responsible for the integration in our CI/CD pipeline

name: CI

concurrency: integration

on:  # TODO Change the trigger events' logic (or leave if you are sure it's ok (but it's probably not)). Maybe do that branch have to start with "dev_" or branch main but only for /src
  workflow_dispatch:
  push:
    branches: [main]
    paths:
      - 'src/**'
      - '!src/**/README.md'
  pull_request:
    branches: [main]
    paths:
      - 'src/**'
      - '!src/**/README.md'

env:
  AWS_REGION: us-east-2

jobs:
  lint:
    runs-on: ubuntu-22.04
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 16
          cache: 'npm'

      - run: npm ci

      - name: Run Super-Linter
        uses: super-linter/super-linter/slim@v5
        env:
          DEFAULT_BRANCH: main
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          VALIDATE_ALL_CODEBASE: false  # TODO This line should be set only if the repository is first properly linted before first usage of this line
          #FILTER_REGEX_INCLUDE: .*src/.*  # Uncomment to inlude only files within /src
          #FILTER_REGEX_EXCLUDE: .*/.github/workflows/.*  # Uncomment to exclude workflow files

  build-unit-test-image:  
    runs-on: ubuntu-22.04    
    permissions:
      packages: write  # Obtain permission needed to push docker image to ghcr.io
    steps:    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to ghcr.io registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # Use GHCR as a register for test images
    - name: Build and Push to GHCR
      uses: docker/build-push-action@v4
      with:
        target: unit-test
        push: true
        tags: ghcr.io/jakubszuber/react-nginx-image:unit-test-${{ github.run_id }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  build-test-image:  
    runs-on: ubuntu-22.04
    permissions:
      packages: write  # Obtain permission needed to push docker image to ghcr.io
    steps:    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2

    - name: Login to ghcr.io registry
      uses: docker/login-action@v2
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    # Use GHCR as a register for test images
    - name: Build and Push to GHCR
      uses: docker/build-push-action@v4
      with:
        push: true
        tags: ghcr.io/jakubszuber/react-nginx-image:${{ github.run_id }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        platforms: linux/amd64

  test-unit:
    name: Unit tests in Docker
    needs: [build-unit-test-image]
    runs-on: ubuntu-latest

    permissions:
      packages: read  # Obtain permission needed to pull docker image to ghcr.io

    steps:
      - name: Login to ghcr.io registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Unit Testing in Docker
        run: |
          docker run --rm ghcr.io/jakubszuber/react-nginx-image:unit-test-"$GITHUB_RUN_ID" sh -c "cd /test-app && npm test"

# You can also do Integration Testing with usage of Docker Compose if you would like to use multiple different containers for the application logic
#  test-integration:
#    name: Integration tests in Compose
#    needs: [build-test-image]
#    runs-on: ubuntu-latest
#
#    permissions:
#      packages: read  # Obtain permission needed to pull docker image to ghcr.io
#
#    steps:
#      - name: Checkout git repo
#        uses: actions/checkout@v3
#
#      - name: Login to Docker Hub
#        uses: docker/login-action@v2
#        with:
#          username: ${{ secrets.DOCKERHUB_USERNAME }}
#          password: ${{ secrets.DOCKERHUB_TOKEN }}
#      
#      - name: Login to ghcr.io registry
#        uses: docker/login-action@v2
#        with:
#          registry: ghcr.io
#          username: ${{ github.actor }}
#          password: ${{ secrets.GITHUB_TOKEN }}
#
#      - name: Test healthcheck in Docker Compose
#        run: |
#          export TESTING_IMAGE=ghcr.io/jakubszuber/react-nginx-image:"$GITHUB_RUN_ID"
#          echo Testing image: "$TESTING_IMAGE"
#          docker compose -f docker-compose.test.yml up --exit-code-from service1

  test-k3d:
    name: Test Deployment in Kubernetes
    needs: [build-test-image]
    runs-on: ubuntu-latest

    permissions:
      packages: read  # Obtain permission needed to pull docker image to ghcr.io

    steps:
      - name: Checkout git repo
        uses: actions/checkout@v3

      - name: Install Helm
        uses: azure/setup-helm@v3

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Login to ghcr.io registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Run micro Kubernetes cluster for testing purposes
      - uses: AbsaOSS/k3d-action@v2
        with:
          cluster-name: "test-cluster-1"
          args: >-
            --agents 1
            --no-lb
            --k3s-arg "--no-deploy=traefik,servicelb,metrics-server@server:*"

      - name: Smoke test deployment in k3d Kubernetes  # We use here the testing image from GitHub registry
        run: |
          kubectl create secret docker-registry regcred \
            --docker-server=ghcr.io \
            --docker-username=${{ github.actor }} \
            --docker-password=${{ secrets.GITHUB_TOKEN }}
          echo ${{ secrets.GITHUB_TOKEN }} | helm registry login ghcr.io -u $ --password-stdin
          helm install golden-devops-helm-release helm-charts/main-chart --values helm-charts/main-chart/values.yaml --set image.name=ghcr.io/jakubszuber/react-nginx-image,image.tag=$GITHUB_RUN_ID,namespace=argocd,disableTLS=false
          sleep 25
          echo "Spinning containers in progress, please wait..."
          sleep 25
          kubectl describe deployment golden-devops-helm-release --namespace=argocd
          kubectl logs -l app=golden-devops-helm-release --namespace=argocd
          kubectl get all --all-namespaces
          echo "------- Eventual Troubleshooting --------"
          sudo apt-get install jq
          POD1=$(kubectl get pods -o json --namespace=argocd | jq -r '.items[0].metadata.name')
          POD2=$(kubectl get pods -o json --namespace=argocd | jq -r '.items[1].metadata.name')
          echo "First pod: $POD1"
          echo "Second pod: $POD2"
          kubectl logs --namespace=argocd $POD1
          kubectl logs --namespace=argocd $POD2
          kubectl rollout status deployment golden-devops-helm-release --namespace=argocd
          echo "Finished setting up"

      - name: Test deployment
        run: |
          sleep 3
          kubectl exec deploy/golden-devops-helm-release --namespace=argocd -- curl -k --fail https://localhost:8080
          helm test golden-devops-helm-release
          if [ $? -ne 0 ]; then 
            echo "Testing of Helm golden-devops-helm-release failed!"
            kubectl logs golden-devops-helm-release-connection-test --namespace=argocd
            exit 1
          fi

  scan-image-Trivy:
    name: Scan Image with Trivy
    needs: [build-test-image]
    runs-on: ubuntu-latest

    permissions:
      contents: read  # Obtain permission needed for actions/checkout to fetch code
      packages: read  # Obtain permission needed to push docker image to ghcr.io
      security-events: write  # Obtain permission needed for github/codeql-action/upload-sarif to upload SARIF results

    steps:
      - name: Checkout git repo
        uses: actions/checkout@v3
      
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
          
      - name: Login to ghcr.io registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image to scan
        run: docker pull ghcr.io/jakubszuber/react-nginx-image:"$GITHUB_RUN_ID"

      # Gain an additional overview of the vulnerabilities
      - name: Run Trivy for all CVEs (non-blocking)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ghcr.io/jakubszuber/react-nginx-image:${{ github.run_id }}
          exit-code: 0
          format: table

      - name: Run Trivy for all CVEs (blocking)
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ghcr.io/jakubszuber/react-nginx-image:${{ github.run_id }}
          exit-code: 1
          severity: 'CRITICAL'
          format: table 

      - name: Run Trivy for HIGH CVEs and report
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ghcr.io/jakubszuber/react-nginx-image:${{ github.run_id }}
          exit-code: 0
          vuln-type: 'os,library'
          ignore-unfixed: true  #TODO uncomment when all scans-related code will be finished (before uncommenting clear entire github scanning)
          severity: 'HIGH'
          format: 'template'
          template: '@/contrib/sarif.tpl'
          output: 'trivy-results.sarif'

      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  scan-code-Snyk:
    name: Scan Code with Snyk
    runs-on: ubuntu-latest
    permissions:
      security-events: write
    steps:
      - name: Checkout git repo
        uses: actions/checkout@v3

      # Gain an additional overview of the vulnerabilities
      - name: Run Snyk to check the code for vulnerabilities (non-blocking)
        continue-on-error: true
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}

      - name: Run Snyk to check the code for vulnerabilities (blocking)
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=critical

      - name: Run Snyk for HIGH CVEs and report
        continue-on-error: true
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          args: --severity-threshold=high --sarif-file-output=snyk.sarif

      - name: Upload result to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'snyk.sarif'

  scan-image-Snyk:
    name: Scan Image with Snyk
    needs: [build-test-image]
    runs-on: ubuntu-latest
    permissions:
      security-events: write
    steps:
      - name: Checkout git repo
        uses: actions/checkout@v3

      - name: Login to ghcr.io registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Pull image to scan
        run: docker pull ghcr.io/jakubszuber/react-nginx-image:"$GITHUB_RUN_ID"

      # Gain an additional overview of the vulnerabilities
      - name: Run Snyk to check Docker image for vulnerabilities (non-blocking)
        continue-on-error: true
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ghcr.io/jakubszuber/react-nginx-image:${{ github.run_id }}
          args: --file=Dockerfile

      - name: Run Snyk to check Docker image for vulnerabilities (blocking)
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ghcr.io/jakubszuber/react-nginx-image:${{ github.run_id }}
          args: --file=Dockerfile --severity-threshold=critical

      - name: Run Snyk for HIGH CVEs and report
        continue-on-error: true
        uses: snyk/actions/docker@master
        env:
          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}
        with:
          image: ghcr.io/jakubszuber/react-nginx-image:${{ github.run_id }}
          args: --file=Dockerfile --severity-threshold=high --sarif-file-output=snyk.sarif

      - name: Upload result to GitHub Code Scanning
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'snyk.sarif'


# TODO Uncomment below and move the below two lines, uncomment and configure the rest of the below part, and setup Datree on the Datree website when you will have implemented Helm
# TODO FIND TOOL SIMILAR TO DATREE
#  datree-k8s-policy-check:
#    runs-on: ubuntu-latest
#    defaults:
#      run:
#        shell: bash
#        working-directory: helm-charts/main-chart
#    env:
#      DATREE_TOKEN: ${{ secrets.DATREE_TOKEN }}
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v2
#
#      - name: Run Datree Policy Check
#        uses: datreeio/action-datree@main
#        with:
#          path: '.'
#          cliArguments: ''
#          isHelmChart: true
#          helmArguments: '--values values.yaml -f helm-charts/main-chart/values-prod.yaml'
#
#      - name: Upload analysis results to GitHub
#        uses: github/codeql-action/upload-sarif@v2
#        with:
#          sarif_file: datree.sarif
#          wait-for-processing: true

  build-final-image:
    name: Build Final Image
    # TODO later add "Datreek8sPolicyCheck" and "scan-artifact-AWS-CodeGuru" and "snyk2" "snyk3"
    # Add "test-integration" to the below list if you want to use integration testing
    needs: [lint, test-unit, test-k3d, scan-image-Trivy, scan-code-Snyk, scan-image-Snyk]
    runs-on: ubuntu-latest

    permissions:
      packages: write  # Obtain permission needed to push docker image to ghcr.io
      pull-requests: write  # Obtain permission needed to create and update comments in PRs

    steps:
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Login to ghcr.io registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Docker meta for the final image  # Add multiple tags to the image
        id: docker_meta
        uses: docker/metadata-action@v4
        with:
          images: ghcr.io/jakubszuber/react-nginx-image,JakubSzuber/react-nginx-image
          flavor: |
            latest=true
          tags: |
            type=semver,pattern={{version}},value=v1.0.0
            type=semver,pattern={{major}}.{{minor}},value=v1.0.0
            type=ref,event=pr
            type=sha,format=long
            type=raw,value=stable-{{date 'YYYYMMDD'}}-{{sha}},enable={{is_default_branch}}

      # TODO Make sure that below part is fully logical
      - name: Build Docker image and push it to GHCR and Docker Hub if the event is a direct push or merged pull request
        uses: docker/build-push-action@v4
        with:
          push: ${{ github.event_name != 'pull_request' }}
          tags: ${{ steps.docker_meta.outputs.tags }}
          labels: ${{ steps.docker_meta.outputs.labels }}
          cache-from: type=gha  # Use cached image layers to reduce image building time
          cache-to: type=gha,mode=max
          platforms: linux/amd64  # You can change to "linux/amd64,linux/arm/v7,linux/arm64"

      # If PR, put image tags in the PR comments
      # from https://github.com/marketplace/actions/create-or-update-comment
      - name: Find comment for image tags
        uses: peter-evans/find-comment@v2
        if: github.event_name == 'pull_request'
        id: fc
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-author: 'github-actions[bot]'
          body-includes: Docker image tag(s) pushed

      # If PR, put image tags in the PR comments
      - name: Create or update comment for image tags
        uses: peter-evans/create-or-update-comment@v2
        if: github.event_name == 'pull_request'
        with:
          comment-id: ${{ steps.fc.outputs.comment-id }}
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            Docker image tag(s) pushed:
            ```text
            ${{ steps.docker_meta.outputs.tags }}
            ```
            Labels added to images:
            ```text
            ${{ steps.docker_meta.outputs.labels }}
            ```
          edit-mode: replace

  notify-slack:
    # Setup guide https://github.com/marketplace/actions/slack-send#technique-3-slack-incoming-webhook
    name: Notify Slack
    needs: [build-final-image]
    if: always()
    runs-on: ubuntu-latest
    env: 
      STAT: ${{ needs.build-final-image.result }}
    steps:
      - name: TEST1
        run: |
          if [[ "$STAT" == "skipped" ]]; then
            echo "STAT=failure" >> "$GITHUB_ENV"
          fi
      - name: TEST
        run: |
          echo "$STAT"
          echo ${{ env.STAT }}
      - uses: 8398a7/action-slack@v3
        with:
          status: ${{ env.STAT }}
          fields: repo,message,author,commit,action,eventName,ref,workflow,job,took,pullRequest
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always() # Pick up events even if the job fails or is canceled.
